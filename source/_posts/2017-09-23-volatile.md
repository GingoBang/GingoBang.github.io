---
layout:		post
title: 		"volatile语义"
date: 		2017-09-23 23:40:44
author:		ruijie
catalog:	true
tags:
	- 并发
---

> volatile: 内存可见性以及禁止指令重排序

---

## 一. 背景

#### 1. 内存模型
在说volatile语义之前简单说一下内存模型

- 硬件内存模型：在程序运行过程中，需要有主内存，寄存器以及CPU来共同完成计算，为了解决多核心CPU和的读写速度与普通主内存的速度上的“量级”差距，中间加入了寄存器这样的告诉缓存。为了解决多核心CPU对应多个高速缓存和一个主内存之间的数据不一致问题，引入了缓存一致性协议，比如`MSI`，`MESI`等
- Java内存模型：为了屏蔽不同硬件平台的差异性，使得不同平台下都能达到并发一致性，在硬件内存模型上抽象出Java内存模型 -- `JMM`。主要由线程，工作内存和主内存来完成计算，相对于硬件内存模型，JMM中的主内存和工作内存并不能完全映射到硬件主内存和寄存器，但是可以类比的来看

#### 2. 内存间交互操作

- *lock* : 锁定主内存中的变量，把它标识为线程独占状态
- *unlock* : 将主内存中处于锁定状态的变量解锁
- *read* : 将主内存中的变量的值传输到线程的工作内存中，以便后续的`load`操作(作用于主内存变量)
- *load* : 将`read`操作传入的变量值拷贝到工作内存的变量副本中(作用于工作内存变量)
- *use* : 作用于工作内存变量，把变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量值的字节码指令时(比如getstatic)，将执行这个操作
- *assign* : 作用于工作内存变量，把一个从执行引擎接收到的值赋值给工作内存中的变量，每当虚拟机遇到给变量赋值的字节码指令(比如putstatic)时将执行这个操作
- *store* : 作用于工作内存的变量，把变量的值传递给主内存，以便后续的`write`操作
- *write* : 作用于主内存，将从工作内存接收到的变量的值放入主内存中

---

## 二. *volatile*语义

1. 保证`volatile`修饰变量的内存可见性
2. 防止指令重排序，JVM或者说编译器会在不影响线程内的计算结果的情况下，在进行优化时可能会进行指令重排序

#### 1. 内存可见性

`volatile`变量的可见性的含义是，线程对于变量的修改会被立即刷新到主内存，而对于变量的读取则每次重主内存读取，从而保证一个线程对于变量的修改能够立即被其他线程所看到，即可见性。

```
//volatile修饰状态量
volatile boolean flag;

//线程A调用此方法
void updateFlag(){
    flag = true;
}
//线程B调用此方法
public void testVolatile(){
    //线程A对于flag的修改会随后被线程B发现
    while (!flag) {
        //do something
    }
}
```
#### 2. 重排序

在不影响程序行为的情况下，JVM出于性能原因可能会对指令进行重排序(表现为线程内语义不变)，如果使用`volatile`来修饰变量，则禁止JVM进行重排序。

```
private Object   object       = null;
private volatile hasNewObject = false;

public void put(Object newObject) {
    while(hasNewObject) {
        //wait - do not overwrite existing new object
    }
    object = newObject;
    hasNewObject = true; //volatile write
}

public Object take(){
    while(!hasNewObject){ //volatile read
        //wait - don't take old object (or null)
    }
    Object obj = object;
    hasNewObject = false; //volatile write
    return obj;
}
```
假设这里不使用`volatile`修饰变量，那么可能会出现以下情况：
```
public void put(...){
    hashNewObject = true;
    object = newObject;
}
```
线程B看到了*hashNewObject = true*，但是这是重排序的结果，*object = newObject* 还没有被执行，就会出现问题。

#### 3. 并发情况下使用*volatile*是否能解决所有问题？

结果是否定的，最简单的情况：
```
volatile int count;
    
public int getCount(){
    return count++;
}
```

因为`count++`并不是原子操作，并且每次累加都依赖于之前的结果，那么就会出现在非原子操作时已经有其他线程将新的`count`值刷新回主内存了，那么我们的计算依赖的就是过期结果，这是不对的。

另外我们将以上代码通过反编译：
```
//形如下：
0: getstatic
1: iconst_1
2: iadd
3: putstatic
...

```
虽然我们在`getstatic`指令下能够保证可见性，但是由于是非原子操作，中间可能已经被其他线程刷新了新的值，因此在这种情况下只是用`volatile`是不够的，需要增加同步机制。

简单的说，使用`volatile`需要满足以下条件：
- 运算结果并不依赖变量的当前值，或者能确保只有单一线程修改变量的值
- 变量不需要和其他变量共同参与不变约束